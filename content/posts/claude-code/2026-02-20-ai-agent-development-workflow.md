---
title: "백엔드 개발자가 AI 에이전트 파이프라인을 설계한 과정"
date: 2026-02-20
categories: ["claude-code"]
tags: ["claude-code", "AI agent", "automation", "plugin", "multi-agent", "superpowers", "개발 프로세스"]
---

## 📌 배경

포트폴리오 사이트를 만들면서 반복 작업이 보였습니다. Claude Code로 개발하면 세션 로그가 남는데, 그걸 매번 수동으로 블로그 글로 정리하고 있었습니다. 세션 데이터 → 블로그 포스트 변환을 자동화하면 되겠다고 판단했고, Claude Code 플러그인으로 만들었습니다.

문제는 "AI가 글을 쓰면 AI 냄새가 난다"는 점이었습니다. 이 글은 그 설계 과정의 기록입니다.

---

## ❌ 단일 에이전트의 한계

처음에는 하나의 에이전트에 "세션 로그를 읽고 블로그 글을 써라"라고 시켰습니다.

결과물의 문제:

| 항목 | 증상 |
|------|------|
| 구조 | 세션 순서 그대로 나열, 독자 관점 부재 |
| 문체 | "이번 포스트에서는 X를 알아보겠습니다" 류의 AI 템플릿 |
| 정보 밀도 | 불필요한 맥락 설명이 절반 이상 |
| 일관성 | 실행할 때마다 톤이 달라짐 |

원인은 하나의 프롬프트에 너무 많은 역할을 부여한 것이었습니다. 세션 데이터 파싱, 핵심 내용 추출, 글 구조화, 문체 적용을 전부 한 번에 처리하려니 어느 것도 제대로 되지 않았습니다.

---

## ✂️ 2단계 파이프라인 분리

백엔드에서 CQRS를 적용할 때와 같은 판단이었습니다. 읽기(추출)와 쓰기(생성)의 요구사항이 다르면 분리합니다.

### Stage 1: 추출 (session-extractor)

세션 로그에서 구조화된 JSON을 뽑아내는 역할입니다. 이 단계는 **정보 손실 없이 구조화**하는 게 목적이라, 창의성이 필요 없습니다.

```json
{
  "files_changed": ["billing/domain/credit.py", ...],
  "decisions": [
    {
      "what": "Pessimistic lock 적용",
      "why": "동시 차감 요청 시 잔액 정합성",
      "alternatives_considered": ["Optimistic lock", "Application-level lock"]
    }
  ],
  "errors_encountered": [...],
  "tools_used": [...]
}
```

### Stage 2: 생성 (writer agents)

JSON raw log를 읽고 목적별 마크다운을 생성합니다. 이 단계는 **톤, 구조, 독자 타겟**이 중요합니다.

| 에이전트 | 출력 | 타겟 독자 |
|---------|------|----------|
| til-writer | TIL 포스트 | 미래의 나 |
| claude-exp-writer | Claude Code 경험 글 | AI 도구에 관심 있는 개발자 |
| project-summarizer | 프로젝트 페이지 | 채용 담당자, 동료 개발자 |
| resume-crafter | 이력서 bullet | 채용 담당자 |

---

## ⚙️ 모델 배치 전략

전부 같은 모델을 쓸 필요가 없습니다.

| 단계 | 모델 | 이유 |
|------|------|------|
| Stage 1 (추출) | Haiku | 구조화 작업. 패턴 매칭과 JSON 변환이 핵심. 속도와 비용 우선 |
| Stage 2 (생성) | Sonnet | 글쓰기. 톤 제어, 문단 구성, 정보 배치가 핵심. 품질 우선 |

Haiku로 추출한 결과를 Sonnet에 넘기면, Sonnet은 원본 세션 로그(수천 줄)를 읽을 필요 없이 정제된 JSON만 보고 글을 씁니다. 컨텍스트 윈도우도 아끼고, 비용도 줄어듭니다.

이건 마이크로서비스에서 가벼운 전처리 워커와 무거운 비즈니스 로직 서비스를 분리하는 것과 같은 패턴입니다.

---

## ✍️ AI 문체 문제 해결

가장 까다로운 부분이었습니다. LLM은 기본적으로 "블로그 글을 써라"고 하면 마케팅 톤을 내뱉습니다.

### 금지 패턴 목록

```
- "이번 포스트에서는 X를 알아보겠습니다"
- "결론적으로"
- "도움이 되셨길 바랍니다"
- "~해 보세요!"
- 감탄사로 시작하는 문장
```

### 요구 패턴 목록

```
- Problem → Cause → Solution 구조
- 비교는 반드시 표(table)로
- 구체적 숫자, 실제 에러 메시지, 파일명 포함
- 입니다체 (해요체/합쇼체 금지)
- 섹션 제목에 이모지
```

이 규칙들은 실제로 제가 쓴 velog 글 5편을 분석해서 추출한 패턴입니다. "좋은 글을 써라"가 아니라 "이 사람처럼 써라"는 구체적인 제약 조건을 주는 게 핵심이었습니다.

---

## 🔄 실제 워크플로우

```bash
# 개발 세션 끝나면
/portfolio wrap

# 내부적으로 실행되는 과정:
# 1. session-extractor(haiku)가 세션 로그 → JSON 변환
# 2. 4개 writer(sonnet)가 병렬로 마크다운 생성
# 3. Hugo front matter 자동 삽입
# 4. content/ 디렉토리에 파일 생성
```

커맨드 하나로 세션 분석부터 포스트 생성까지 끝납니다. 생성된 초안을 검토하고 필요하면 수정한 뒤 커밋하면 됩니다.

---

## 🚀 superpowers 플러그인으로 개발 프로세스 구조화

dev-portfolio가 콘텐츠 생성을 자동화했다면, [superpowers](https://github.com/jlowin/superpowers) 플러그인은 **개발 프로세스 자체를 구조화**합니다. Claude Code에서 사용할 수 있는 스킬 모음인데, 실제로 이 포트폴리오 사이트와 Billing 마이크로서비스 개발에서 적극 활용했습니다.

### 자주 쓰는 스킬과 효과

| 스킬 | 역할 | 체감 효과 |
|------|------|----------|
| `brainstorming` | 구현 전 요구사항과 설계 방향 탐색 | 코딩 시작 전에 접근 방식을 3-4개 비교할 수 있음. "일단 짜고 보자"를 방지 |
| `writing-plans` | 구현 계획서 작성 (태스크 분해) | 17개 태스크로 분해된 계획서가 나옴. 어디까지 했고 뭐가 남았는지 명확 |
| `executing-plans` | 계획서 기반 배치 실행 + 체크포인트 리뷰 | 3개씩 실행하고 중간 검토. 긴 작업에서 방향이 틀어지는 걸 조기 발견 |
| `systematic-debugging` | 버그 원인 분석 프로세스 | 증상 → 가설 → 검증 순서를 강제해서 "이것저것 바꿔보기" 방지 |
| `verification-before-completion` | 완료 선언 전 검증 강제 | "됐습니다" 하고 실제로 안 되는 경우를 차단 |
| `finishing-a-development-branch` | 브랜치 완료 후 통합 옵션 제시 | merge/PR/cleanup 중 선택지를 구조화 |

### 실제 적용 사례: 포트폴리오 사이트 구축

이 사이트를 만들 때 `brainstorming` → `writing-plans` → `executing-plans` 순서로 진행했습니다.

```
brainstorming → 플러그인 구조를 agent/command/skill 3-tier로 결정
writing-plans → 17개 태스크로 분해 (plugin.json, 5개 에이전트, 6개 커맨드, 2개 스킬, 테스트)
executing-plans → 3개씩 배치 실행, 배치마다 리뷰 후 다음 배치 진행
```

이 과정에서 4번째 배치 리뷰 때 에이전트 간 JSON 스키마가 안 맞는 문제를 발견했습니다. 배치 실행 없이 전부 한 번에 짰으면 마지막에 가서야 알았을 문제입니다.

### 실제 적용 사례: Mermaid 다이어그램 렌더링 디버깅

프로젝트 페이지에 Mermaid 다이어그램을 추가했는데, 렌더링이 안 되는 문제가 있었습니다. `systematic-debugging` 접근법으로 원인을 추적했습니다.

```
증상: Mermaid <div> 태그가 페이지에 존재하지만 다이어그램이 안 그려짐
가설 1: mermaid.min.js가 로드되지 않음 → 확인 결과 맞음
가설 2: extend_footer.html override가 동작하지 않음 → 테스트 마커로 확인 → 동작함
가설 3: {{ if .Params.mermaid }} 조건이 false → 디버그 출력으로 확인 → 다른 페이지 컨텍스트
근본 원인: PaperMod가 partialCached로 footer를 캐싱해서 페이지별 Params 참조 불가
해결: DOM 기반 감지(document.querySelector('.mermaid'))로 전환
```

가설을 순서대로 검증하지 않았으면 "Hugo가 이상한가" 하면서 한참 헤맸을 겁니다.

### 스킬 없이 개발할 때 vs 스킬 활용할 때

| 항목 | 스킬 없이 | 스킬 활용 |
|------|----------|----------|
| 설계 | 머릿속으로 대충 잡고 시작 | brainstorming으로 선택지 비교 후 결정 |
| 계획 | "대충 이 순서로 하면 되겠지" | writing-plans로 태스크 분해, 의존 관계 명시 |
| 실행 | 전체를 한 번에 쭉 진행 | 배치 실행 + 체크포인트 리뷰 |
| 디버깅 | 이것저것 바꿔보기 | 가설 → 검증 → 근본 원인 추적 |
| 완료 | "된 것 같은데요" | verification으로 실제 검증 후 완료 선언 |

핵심은 스킬이 **프로세스를 강제**한다는 점입니다. AI 도구를 쓸 때 가장 위험한 건 "빠르게 뭔가 나오니까 검증 없이 넘어가는 것"인데, 스킬이 체크포인트 역할을 합니다.

---

## 🏗️ 백엔드 설계 원칙이 에이전트 설계에도 적용된다

이 플러그인을 만들면서 느낀 점은, 에이전트 파이프라인 설계가 백엔드 아키텍처 설계와 크게 다르지 않다는 것입니다.

| 백엔드 원칙 | 에이전트 적용 |
|------------|-------------|
| 관심사 분리 | 추출과 생성을 다른 에이전트로 분리 |
| CQRS | 읽기(추출)와 쓰기(생성)의 모델을 다르게 |
| 도메인 특화 서비스 | writer마다 다른 출력 포맷과 타겟 독자 |
| 비용 최적화 | 작업 특성에 따라 haiku/sonnet 분리 배치 |
| 멱등성 | 같은 세션 로그로 여러 번 실행해도 동일한 구조의 출력 |

에이전트를 "프롬프트를 잘 쓰는 문제"로만 보면 한계가 있습니다. 시스템으로 설계하면 품질, 비용, 유지보수성을 동시에 잡을 수 있습니다.

그리고 AI 도구를 잘 쓴다는 건 프롬프트를 잘 쓰는 게 아니라, **프로세스를 설계하고 자동화하는 능력**입니다. dev-portfolio로 콘텐츠 생성을 자동화하고, superpowers로 개발 프로세스를 구조화한 것처럼, AI 도구도 아키텍처로 접근해야 확장 가능한 결과가 나옵니다.
