---
title: "백엔드 개발자가 AI 에이전트 파이프라인을 설계한 과정"
date: 2026-02-20
categories: ["claude-code"]
tags: ["claude-code", "AI agent", "automation", "plugin", "multi-agent"]
---

## 0. 배경

포트폴리오 사이트를 만들면서 반복 작업이 보였습니다. Claude Code로 개발하면 세션 로그가 남는데, 그걸 매번 수동으로 블로그 글로 정리하고 있었습니다. 세션 데이터 → 블로그 포스트 변환을 자동화하면 되겠다고 판단했고, Claude Code 플러그인으로 만들었습니다.

문제는 "AI가 글을 쓰면 AI 냄새가 난다"는 점이었습니다. 이 글에서는 그 문제를 포함해서, 멀티 에이전트 파이프라인을 설계하면서 내린 결정들을 정리합니다.

---

## 1. 단일 에이전트의 한계

처음에는 하나의 에이전트에 "세션 로그를 읽고 블로그 글을 써라"라고 시켰습니다.

결과물의 문제:

| 항목 | 증상 |
|------|------|
| 구조 | 세션 순서 그대로 나열, 독자 관점 부재 |
| 문체 | "이번 포스트에서는 X를 알아보겠습니다" 류의 AI 템플릿 |
| 정보 밀도 | 불필요한 맥락 설명이 절반 이상 |
| 일관성 | 실행할 때마다 톤이 달라짐 |

원인은 하나의 프롬프트에 너무 많은 역할을 부여한 것이었습니다. 세션 데이터 파싱, 핵심 내용 추출, 글 구조화, 문체 적용을 전부 한 번에 처리하려니 어느 것도 제대로 되지 않았습니다.

---

## 2. 2단계 파이프라인 분리

백엔드에서 CQRS를 적용할 때와 같은 판단이었습니다. 읽기(추출)와 쓰기(생성)의 요구사항이 다르면 분리합니다.

### Stage 1: 추출 (session-extractor)

세션 로그에서 구조화된 JSON을 뽑아내는 역할입니다. 이 단계는 **정보 손실 없이 구조화**하는 게 목적이라, 창의성이 필요 없습니다.

```json
{
  "files_changed": ["billing/domain/credit.py", ...],
  "decisions": [
    {
      "what": "Pessimistic lock 적용",
      "why": "동시 차감 요청 시 잔액 정합성",
      "alternatives_considered": ["Optimistic lock", "Application-level lock"]
    }
  ],
  "errors_encountered": [...],
  "tools_used": [...]
}
```

### Stage 2: 생성 (writer agents)

JSON raw log를 읽고 목적별 마크다운을 생성합니다. 이 단계는 **톤, 구조, 독자 타겟**이 중요합니다.

| 에이전트 | 출력 | 타겟 독자 |
|---------|------|----------|
| til-writer | TIL 포스트 | 미래의 나 |
| claude-exp-writer | Claude Code 경험 글 | AI 도구에 관심 있는 개발자 |
| project-summarizer | 프로젝트 페이지 | 채용 담당자, 동료 개발자 |
| resume-crafter | 이력서 bullet | 채용 담당자 |

---

## 3. 모델 배치 전략

전부 같은 모델을 쓸 필요가 없습니다.

| 단계 | 모델 | 이유 |
|------|------|------|
| Stage 1 (추출) | Haiku | 구조화 작업. 패턴 매칭과 JSON 변환이 핵심. 속도와 비용 우선 |
| Stage 2 (생성) | Sonnet | 글쓰기. 톤 제어, 문단 구성, 정보 배치가 핵심. 품질 우선 |

Haiku로 추출한 결과를 Sonnet에 넘기면, Sonnet은 원본 세션 로그(수천 줄)를 읽을 필요 없이 정제된 JSON만 보고 글을 씁니다. 컨텍스트 윈도우도 아끼고, 비용도 줄어듭니다.

이건 마이크로서비스에서 가벼운 전처리 워커와 무거운 비즈니스 로직 서비스를 분리하는 것과 같은 패턴입니다.

---

## 4. AI 문체 문제 해결

가장 까다로운 부분이었습니다. LLM은 기본적으로 "블로그 글을 써라"고 하면 마케팅 톤을 내뱉습니다.

### 금지 패턴 목록

```
- "이번 포스트에서는 X를 알아보겠습니다"
- "결론적으로"
- "도움이 되셨길 바랍니다"
- "~해 보세요!"
- 감탄사로 시작하는 문장
```

### 요구 패턴 목록

```
- Problem → Cause → Solution 구조
- 비교는 반드시 표(table)로
- 구체적 숫자, 실제 에러 메시지, 파일명 포함
- 입니다체 (해요체/합쇼체 금지)
- 섹션 제목에 이모지
```

이 규칙들은 실제로 제가 쓴 velog 글 5편을 분석해서 추출한 패턴입니다. "좋은 글을 써라"가 아니라 "이 사람처럼 써라"는 구체적인 제약 조건을 주는 게 핵심이었습니다.

---

## 5. 실제 워크플로우

```bash
# 개발 세션 끝나면
/portfolio wrap

# 내부적으로 실행되는 과정:
# 1. session-extractor(haiku)가 세션 로그 → JSON 변환
# 2. 4개 writer(sonnet)가 병렬로 마크다운 생성
# 3. Hugo front matter 자동 삽입
# 4. content/ 디렉토리에 파일 생성
```

커맨드 하나로 세션 분석부터 포스트 생성까지 끝납니다. 생성된 초안을 검토하고 필요하면 수정한 뒤 커밋하면 됩니다.

---

## 6. 백엔드 설계 원칙이 에이전트 설계에도 적용된다

이 플러그인을 만들면서 느낀 점은, 에이전트 파이프라인 설계가 백엔드 아키텍처 설계와 크게 다르지 않다는 것입니다.

| 백엔드 원칙 | 에이전트 적용 |
|------------|-------------|
| 관심사 분리 | 추출과 생성을 다른 에이전트로 분리 |
| CQRS | 읽기(추출)와 쓰기(생성)의 모델을 다르게 |
| 도메인 특화 서비스 | writer마다 다른 출력 포맷과 타겟 독자 |
| 비용 최적화 | 작업 특성에 따라 haiku/sonnet 분리 배치 |
| 멱등성 | 같은 세션 로그로 여러 번 실행해도 동일한 구조의 출력 |

에이전트를 "프롬프트를 잘 쓰는 문제"로만 보면 한계가 있습니다. 시스템으로 설계하면 품질, 비용, 유지보수성을 동시에 잡을 수 있습니다.
