---
title: "미니언즈 레거시(1) - DDD"
date: 2024-09-19
categories: ["ddd"]
tags: ["DDD"]
series: ["미니언즈 레거시"]
migrated_from: "velog"
---

## Domain Driven Design

DDD는 Eric Evans가 2003년에 출판한 《Domain-Driven Design: Tackling Complexity in the Heart of Software》에서 제시한 방법론으로, 복잡한 소프트웨어 시스템에서 비즈니스 도메인의 이해와 모델링을 중심으로 개발을 진행하는 접근법입니다.

DDD는 도메인 전문가와 개발자가 협력하여 도메인 모델을 구축하고 이를 기반으로 소프트웨어를 설계하고 구현하는 것을 목표로 합니다. 주요 개념으로 도메인(Domain), 도메인 모델(Domain Model), 유비쿼터스 언어(Ubiquitous Language), 바운디드 컨텍스트(Bounded Context), 엔티티(Entity), 값 객체(Value Object), 어그리게이트(Aggregate), 도메인 서비스(Domain Service), 도메인 이벤트(Domain Event) 등이 있습니다.

## 미니언즈의 DDD

### 미니언즈의 DDD 도입과 운영은 성공적이었는가

결론부터 말하면, 개인적인 평가로는 실패에 가깝습니다. 10점 만점에 5점을 주고 싶습니다.

가장 큰 이유는 도메인을 확실하게 정의할 수 있는 전문가가 부족했기 때문입니다. 이로 인해 개발팀과 도메인 비즈니스팀 간에 도메인 모델이나 Ubiquitous Language 정의가 부족했고, 여러 서비스들의 도메인 규칙을 비즈니스 팀이 아닌 개발팀에게 의존하는 경우가 많았습니다.

몇몇 서비스들은 만족스럽게 개발되었는데, 이들 서비스가 잘 만들어질 수 있었던 요인은 구현하고자 하는 도메인을 잘 이해하고 설명할 수 있는 비즈니스 팀원이 함께 있었기 때문입니다.

### 좋았던 혹은 좋지 못했던 케이스들

#### 잘 개발된 케이스 1: 등록할 상품 뽑기 - Ubiquitous Language 정의 성공

이 서비스의 비즈니스 목표는 명확했습니다: "일정 주기로 다량의 상품을 하나의 마켓계정 내에서 중복상품이 없고 마켓계정들 사이에서도 최대한 중복이 없게 뽑아서 등록을 하고 싶다."

요구사항 논의 과정에서 MRC(Market Registration Count)와 같은 Ubiquitous Language가 정의되었습니다. 이 용어는 중복 등록을 방지하기 위해 필수적이었고, 팀원 모두가 명확히 공유하는 용어였기 때문에 개발팀과 비즈니스 팀 간의 소통이 원활했습니다.

예시:
- "이번에 A 상품이 중복등록된 이유는 무엇인가요?" → "해당 상품을 등록 시도했을 때 실패했다고 응답이 와서 MRC가 계속 0인 상태였고 그래서 다음 트리거에 Pick 되어서 등록이 되었습니다."

- "현재 A 마켓의 B 계정에 C상품을 등록해도 괜찮나요?" → "C 상품의 MRC가 1이긴 한데 X 계정에 등록되어있기 때문에 등록은 가능합니다."

- "현재 A 마켓에 등록 가능한 상품이 총 몇 개 인가요?" → "MRC 0인 상품 기준으로 N개 상품이 등록 가능합니다."

그 외에도 상품을 뽑는 행위를 "Pick", 상품 등록/수정/품절/삭제를 "RESD", 등록하기 위해 Pick한 상품들을 "Candidate" 등 Ubiquitous Language을 잘 정의함으로써 소통의 효율성을 높일 수 있었고 안정적인 서비스 유지보수가 가능했습니다.

#### 잘 개발된 케이스 2: 정산 - Event Storming

Event Storming은 도메인 주도 설계(DDD)에서 복잡한 비즈니스 도메인을 이해하기 위한 워크숍 기반의 협업 도구입니다. 이 방법론은 팀이 함께 도메인 이벤트를 탐색하고 시각적으로 표현함으로써 시스템의 도메인 흐름과 관계를 이해하는 데 도움을 줍니다.

정산의 경우 몇 년간 전문적으로 담당했고 이를 잘 설명할 능력이 있는 도메인 전문가 직원이 있었습니다. 그 직원과 함께 Event Storming를 진행하여 정산 프로세스를 정리했고 DDD 패턴의 로직 설계에 필요한 Domain Event, Aggregate, Policy 등을 쉽게 도출하고 파악할 수 있었습니다.

특히 평소에 설계할 때는 Aggregate를 먼저 정의하고 Domain Event를 이어나갔지만 Event Storming을 통해서는 Domain Event를 먼저 정의함으로서 도메인의 흐름을 더 빨리 쉽게 이해할 수 있었습니다.

필요한 Ubiquitious Language와 Aggregate가 잘 정리되었으며 Domain Event로 Aggregate 간의 관계 및 프로세스도 잘 정리되었습니다. 도메인 논의 과정에서 놓쳤고 보완해야하는 규칙이나 프로세스도 운영 중에 발견했지만 전체 구조를 잘 갖추었기 때문에 유연하게 추가 로직 확장이 가능했습니다.

#### 잘못 개발된 케이스: 주문 관리, 클레임 관리 - 도메인 정의 부족

주문, 클레임 관리 서비스는 설계 과정에서 개발 일정 및 도메인 전문가의 전문성 및 인력 부족으로 적극적인 참여 없이 진행하게 되었습니다.

열심히 관련 업무를 하는 비즈니스팀 동료들에게 물어보면서 도메인을 도출하려고 노력하긴 했지만 그들도 요구사항과 도메인 프로세스가 확실하게 정리되지 않은 상태였고, 중간중간 설계 중인 작업물을 피드백 받지도 못한 상태로 개발하게 되었습니다.

그렇게 개발된 Aggregate의 응집도는 낮았고 필요한 요구사항이 생길 때마다 이미 부하가 걸린 Aggregate에 기능을 추가하다보니 DB row에서 concurrency 이슈가 발생하기도 하고 너무 많은 상태값을 관리하다보니 사용자들의 혼란도 야기했습니다. 특정 기능들은 사용성이 떨어져 애써 만들었지만 존재 의미가 없어지기도 했습니다.

## [마무리] DDD로 개발하며 느낀 점

도메인 전문가가 있는 환경에서는 DDD가 매우 효과적인 디자인 패턴입니다. 도메인 이해와 분석이 잘 되어 있는 비즈니스에서는 DDD를 적극 추천합니다. DDD는 개발자와 사용자 간의 커뮤니케이션을 명확히 하고, 비즈니스 확장이나 새로운 규칙 도입에 유연하며, 복잡한 도메인 로직에 대한 테스트도 용이하게 합니다.

그러나 도메인 전문가가 부족하거나 개발 결과물을 신속히 만들어야 하는 비즈니스 환경에서는 DDD가 과도할 수 있습니다. DDD는 개발보다 설계, 설계보다 도메인 이해와 분석이 중요합니다. 일정에 쫓겨 빠르게 개발한 서비스는 유지보수와 비즈니스 확장에 어려움을 겪을 수 있으며, 준비가 부족한 상태에서 개발을 진행하면 나중에 개발 부채를 감당하기 어려울 수 있습니다.

개발된 코드는 구조적으로 안정적이었으나, "DDD의 핵심은 도메인 전문가와의 협력과 도메인 모델링, Ubiquitous Language 구축"이라는 점을 느꼈습니다.
