---
title: "[ADR-004] 마이크로서비스 간 통신에 gRPC를 선택한 이유"
date: 2026-02-20
categories: ["ddd"]
tags: ["gRPC", "MSA", "ADR", "아키텍처", "Protocol Buffers"]
series: ["Billing 마이크로서비스 ADR"]
series_order: 4
---

> **이 시리즈**: Billing 마이크로서비스 설계 결정 기록. [ADR-001](/posts/ddd/2026-02-20-adr-001-bounded-context/) · [ADR-002](/posts/ddd/2026-02-20-adr-002-customer-aggregate/) · [ADR-003](/posts/ddd/2026-02-20-adr-003-pessimistic-lock/)에서 이어집니다.

---

## 상황 (Context)

Billing 서비스는 고객 정보 조회를 위해 Account 서비스와 통신합니다. 특정 조직의 구독 상태를 확인하거나, 크레딧 계좌를 생성할 때 Account 서비스에서 고객 정보를 가져와야 합니다.

마이크로서비스 간 통신 방식을 결정해야 했습니다.

---

## 문제 (Problem)

주요 선택지:

| 방식 | 특징 |
|------|------|
| **REST (JSON)** | 표준화된 방식, 별도 스키마 없음, 런타임에 오류 발견 |
| **gRPC (Proto)** | Proto 파일이 스키마 계약, 컴파일 타임에 오류 발견, 바이너리 직렬화 |
| **메시지 큐** | 비동기, 느슨한 결합, 즉각적 응답이 필요한 경우 부적합 |

Billing ↔ Account 간 통신의 특성:
- **동기 호출**: 크레딧 계좌 생성 시 고객 정보가 즉시 필요
- **빈번한 호출**: 결제 처리마다 고객 PG 매핑 조회
- **두 서비스가 함께 개발됨**: 인터페이스 변경이 잦을 수 있음

---

## 결정 (Decision)

**Billing ↔ Account 간 동기 통신에 gRPC를 적용합니다.**

```protobuf
// account.proto
service AccountService {
  rpc GetCustomer(GetCustomerRequest) returns (CustomerResponse);
  rpc ListCustomers(ListCustomersRequest) returns (ListCustomersResponse);
}

message GetCustomerRequest {
  string organization_id = 1;
}

message CustomerResponse {
  string customer_id = 1;
  string organization_id = 2;
  string name = 3;
  bool is_active = 4;
}
```

Proto 파일이 두 서비스 간의 API 계약입니다. 한쪽이 인터페이스를 변경하면 Proto를 수정하고, 양쪽 모두 재생성된 코드로 컴파일합니다.

---

## 이유 (Rationale)

**핵심 이유: 인터페이스 변경을 컴파일 타임에 잡는다**

REST로 개발하면 인터페이스 변경이 런타임 오류로 드러납니다. Account 서비스가 응답 필드를 추가·삭제해도 Billing 쪽에서 바로 알 수 없습니다. 운영 중에 `KeyError`나 `None`으로 발견합니다.

gRPC는 Proto 파일이 강제 계약입니다. 필드를 바꾸면 양쪽 다 재컴파일 → 타입 불일치를 빌드 단계에서 발견합니다.

**두 번째 이유: Proto가 문서화를 대체한다**

REST API는 Swagger 같은 별도 문서 도구가 필요합니다. 문서와 실제 구현이 따로 놀기 쉽습니다. Proto 파일 자체가 인터페이스 명세입니다. "Account 서비스가 뭘 줄 수 있나"는 proto 파일 한 개로 답이 나옵니다.

**REST를 선택하지 않은 이유:**

- 두 서비스가 함께 개발되는 초기에 인터페이스 변경이 잦았음
- JSON은 타입 강제가 없어 필드 추가·제거 시 양쪽 합의가 암묵적으로 이뤄짐
- 빈번한 동기 호출에서 JSON 직렬화/역직렬화 오버헤드

**메시지 큐를 선택하지 않은 이유:**

크레딧 계좌 생성 시 고객 정보가 즉시 필요합니다. 비동기 방식은 "고객 정보 요청을 보내고 나중에 처리"인데, 이 흐름에서는 응답이 와야 다음 단계로 진행할 수 있습니다.

---

## 결과 (Outcome)

**실제로 발견한 효과:**

서비스 개발 초기에 Account 팀이 `organization_id` 필드를 `account_id`로 rename했습니다. Proto 수정 → 양쪽 재컴파일 → Billing 쪽 컴파일 오류 발생 → 수정. 이 과정이 30분 안에 끝났습니다. REST였다면 런타임에 `KeyError: 'organization_id'`로 발견했을 겁니다.

**트레이드오프:**

| 장점 | 단점 |
|------|------|
| 인터페이스 변경을 컴파일 타임에 감지 | Proto 파일 관리 필요 (공유 레포 or 복사) |
| 바이너리 직렬화로 빠른 통신 | HTTP/2 기반이라 디버깅이 REST보다 불편 |
| Proto = 문서화 | 브라우저에서 직접 호출 불가 |

외부 API(클라이언트 노출)는 REST로, 내부 서비스 간 통신은 gRPC로 나누는 방식이 현재 구조입니다.
